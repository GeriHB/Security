In the JWT header only the `alg` parameter is mandatory. But, in practice there are also other parameters.
- `jwk` - (JSON Web Key) is an embedded JSON object representing the key.
- `jku` - (JSON Web Key Set URL) is a URL from which servers can fetch a set of keys containing the correct key.
- `kid` - (Key ID) an ID that servers use to identify the correct key where there are multiple keys.

These all are user-controllable parameters and tell the server which key to use when verifying the signature.

## Injecting Self-Signed JWTs via the `JWK` Parameter

An example:

```json
{
    "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
        "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m"
    }
}
```

`jwk` is a parameter which servers can use to embed their public key directly within the token.

Ideally servers should only use a limited whitelist of public keys to verify JWT signatures, but misconfigured servers sometimes use any key that's in the `jwk`.

This behavior can be exploited by signing a modified JWT using your own RSA private key, then embedding the matching public key in the `jwk` header.

### Lab.4 JWT Authentication Bypass via JWK Header Injection

Server supports `jwk` parameter, which sometimes is used to embed the correct verification key directly in the token. However it fails to check whether the provided key came from a trusted source.

To solve the lab access `/admin` and delete `carlos`. Usable credentials are `wiener:peter`.

I login with `wiener` credentials and send the request to the Burp Repeater.

I go to the `JWT Editor` and click on `New RSA Key`. There I click `Generate` and then don't change anything, and click ok, and it will create a new key.

![Pasted_image_20250123115314](https://github.com/user-attachments/assets/ab38c4a5-fd38-4ea1-aaa2-031e91fc2ef0)

I go back to the Repeater, under `JSON Web Token` and change the `"sub:"` to `administrator`, and click on `Attack`, then choose `Embedded JWK`.

![Pasted_image_20250123115423](https://github.com/user-attachments/assets/cba0cb35-bb12-4c45-9478-e2e2f627f346)

After choosing our crafted key, the header is modified:

```json
{
    "kid": "09b28d6e-4676-48ce-bd59-2d65d05e25b7",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "09b28d6e-4676-48ce-bd59-2d65d05e25b7",
        "n": "2AXM5gKLzKPEYhyPsu-jvST-HWQGmSmmHDglRzC2j_6HUBXXyOHfhuLH15jFfGk1FwGskZjtSR74hRJ76pGg9xhyeA9hnhUxaUPQhyd6rnuXG_0o8XMAKwIwd2oWpuh4giJGGwNvlICG6MPBGDK_o59gVVlo04d3As7j95pJH1qV0o0uzjwmwxCMRKJZQ964W5tUNadFehZkwbp20CEAGQcdMaGUd8nWg3ekzKBT7U5vdnIUQtR4HVLBHGCfJjmiH9dadyUz6Nixov60BNvC4O_7OZQ-DFeDOoy-2uPxpjqqGm7UMxA4Za90FWbWEGgUPIKmtQ8Ye4fggaw27WSgKw"
    }
}
```

I send the request to `/admin` and I gain access to the admin page. Then I just copy the delete link for `carlos` and send a request there, and the lab is solved.

-------

## Injecting Self-Signed JWTs via the `jku` Parameter

Some servers let you use the `jku` parameter to reference a JWK set containing the key, and when verifying the signature, the server fetches the relevant key from this URL.

An example of a JWK set:

```json
{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        }
    ]
}
```

### Lab.4 - JWT Authentication Bypass via `jku` Header Injection

The server supports `jku` parameter, but it fails to check whether the provided URL belongs to a trusted domain. 

The goal of the lab is to forge a JWT that gives access to the `/admin` and delete `carlos`.

`wiener:peter` can be used to login. 

I sent the login request with the `wiener:peter` credentials to the Burp Suite, and change the path to `/admin`.

But, as expected I'm not authorized to open that page.

Since the lab supports `jku` I go to the `JWT Editor` and generate a `New RSA Key`.

After it has been generated, I right click on the new key and copy the public key as JWK.

I go to the exploit server, and paste the key there, in the body.

It's important that the copied key to be pasted inside:

```json
{
	"keys": [
	
	]
}
```

The final body in my case is:

```json
{
    "keys": [
{
    "kty": "RSA",
    "e": "AQAB",
    "kid": "9678d3ac-6a40-480c-ba36-f9f88fcba0e6",
    "n": "-e9gHyUdYgyOM7MJKF08XtDlOVv_JkA5EFgmcCWw8hbuL2eoG72tHjec8jv_9h77TXJZ_PeBnV5YJU3A_kMMhKMNAjjde3cdA0Rcy1uu-th0WDvT0JVsIx0wwPuKhr_726qQDlpD4dkmCnWrkJEL4ljZyLToCuZgeJgR0UhygFS8Rt7qiAFEve05xDokmAuOGsWrCgV0-COTk8GeM-FZCDDKHuuUKuD-px2wQV4-NWGcqngwmFYVXgSpRgFlBW6gll5M7zmor6A2z3QyqsGhzXuR2srrMcL5AdzDIzaEGC5q1KYhV4ofn3KGywebijA_9IhmnpWXUb5eG8x-B4jF5w"
}

    ]
}
```

Copy the `kid` and replace it in the Burp Repeater -> JSON Web Token:

![Pasted_image_20250123131939](https://github.com/user-attachments/assets/ac5dd986-4f07-45e0-8f4b-88a300e0e582)

Add a new header `jku` and paste the exploit server URL:

![Pasted_image_20250123132216](https://github.com/user-attachments/assets/c6c22260-407e-4c5b-8e33-4638d28fef1d)

Change the `"sub":` to administrator, and click on `Sign` to use the new generated key.

![Pasted_image_20250123132255](https://github.com/user-attachments/assets/2876b508-3338-4135-8a6c-b308843c7c16)

Then I sent again the request to the `/admin` and I have access. There I copy the link to delete `carlos`, and the lab is solved.

--------

## Injecting Self-Signed JWTs via the `kid` parameter

As servers can use several cryptographic keys to sign different kinds of data and not just JWTs, the header contains a `kid` parameter to help the server identify which key to use to verify the signature.

Verification keys usually are stored as JWK sets, and the server may simply look for the JWK with the same `kid` as the token.

Also, the `kid` doesn't have a concrete structure, it's just an arbitrary string that the developer choses. `kid` may point to an entry in the database or a name of the file.

It can even be vulnerable to `path traversal`.

It's very dangerous if the server supports `symmetric algorithm`, as the attacker can point to a static file, and sign the JWT using a secret that matches the contents of this file.

A simple way to do this is to use `/dev/null` which is an empty file and returns an empty string, therefore signing the token with an empty string results in a valid signature.

### Lab.5 JWT Authentication Bypass via `kid` Header Path Traversal

In order to verify the signature, the server uses the `kid` to fetch the relevant key from the filesystem.

The goal is to forge a JWT that gives access to `/admin` and then delete `carlos`.

You can login with `wiener: peter`

I login with `wiener:peter` credentials and send the request to BURP. `/admin` is unaccessible as I'm not authorized to visit the admin page.

I go to the `JWT Editor Keys` and generate a `New Symmetric Key`, and as the easiest way to point to the same file, is to point to an empty file, i should put here in the `k` parameter with the null byte. 

Null byte base64 encoded is `AA==`:
![Pasted_image_20250123135246](https://github.com/user-attachments/assets/3880ed21-9131-4032-8b5e-ffcc6918c662)

On the request that I sent to the Repeater, under the `JSON Web Token`, i modify the `kid` parameter and point that to the empty file `/dev/null` and the `sub` parameter in the body and make it `administrator`.

After those edits, I click Sign and choose our symmetric key that was created before.

Then with the new token I send the request to `/admin` and I gain access there, where I also find the link to delete the user `carlos` and after sending the request there I solve the lab.

-----

## Other Parameters

`cty` (Content Type) - If you have a way to bypass signature verification, you can inject a `cty` header and change the content type to `text/xml` or `application/x-java-serialized-object` which can create new attack vectors for `XXE` and `deserialization attacks`.

`x5c` (X.509 Certificate Chain) - Used to pass X.509 public key certificate or certificate chain of the key used to digitally sign the JWT. It can be used to inject self-signed certificates. `CVE-2017-2800` and `CVE-2018-2633`.







