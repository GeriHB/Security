## Brute-Force Attacks

This attack is whether an attacker uses a system of trial and error to guess the credentials. Usually the attacks are automated using wordlists of usernames and passwords.

But not always this is the case of randomly guessing the username and passwords.

By using basic logic or publicly available knowledge, attackers can tune their brute-force attacks to make more sensible guesses. 

### Username Enumeration

Is when an attacker is able to observe changes in the website's behavior in order to identify if a username is valid or not.

Username enumeration typically occurs:
- login page
- registration forms

This reduces the time and effort that is required for brute-forcing, because the attacker is able to generate a shortlist of valid usernames.

When brute-forcing pay attention to:
- **Status codes** - The returned HTTP status code is mostly the same for the majority of guesses as they are wrong. If the response has a different code, it's an indication that the username was correct. A best practice for websites is to always return the same status code.
- **Error messages** - Sometimes the error message can be different depending of if both username and password are incorrect or only the password is incorrect. Best practice is to use identical, generic messages in both cases.
- **Response times** - When some requests during brute-forcing have different response time, it is an indication that the username is correct, because the website might check if the password is correct..

## Lab. 1 - Username Enumeration via Different Responses

The lab is vulnerable to username enumeration and password brute-force attacks. An account has predictable username and password.

The goal is to enumerate a valid username, brute-force the user's password, and then access the account page.

I went to the login page of the lab and tried just a random user and password. In the Burp, I checked the login request, and saw that both user and password were in the body of the request in the following format:

`username=testUser&password=testPassword`

Now highlight the username value and send it to `Burp Intruder`. 

I selected the `Sniper Attack` and in the `Payloads` tab I selected the type to be `Simple list`. Copy the provided wordlist for usernames in the lab, and paste them in the `payload configuration`. After this, start the attack.

The status code is all the same, but not the length of the response. One of the responses has a length of `3250` while all others have `3248`.

After analyzing the longer response, I see that it writes `Incorrect password`, while on the others it says `Invalid username`.

This means that the username `ap` exists.

Now the goal is to brute-force the password for this username. So, close the intruder tab, and in the body of the request, add the identified user to the username parameter, and make the password as the payload.

`username=ap&password=§testPass§`

Now, repeat the process, just now copy the password wordlist provided from the lab, instead of the username wordlist.

Again while checking the responses, I see one that has a shorter length of `184` in contrast with others that have `3250`.

When checking the response, the status code is `HTTP/2 302 Found`. So we found the username and the password which is `amanda`. Now, I logged in using those, and the lab is solved.

------

### Lab.2 - Username Enumeration via subtly different responses

To solve the lab, enumerate usernames, and brute-force passwords, with the candidate usernames, and candidates passwords provided in the lab.

After getting credentials, login into a user account.

I try to login with some user and password that don't exist, and get the Request that is being sent, via Burp.

The body of the `POST` request is as follows: `username=test&password=testPasswqord`.

After highlighting the value of the username, and sending it to the Intruder, it takes the form of: `username=§test§&password=testPasswqord`.

I choose the `Sniper Attack` with a `Simple list` payload type, and paste the username candidates. 

To make the attack easier, I went to the Settings and under `GREP - extract` and then `Fetch the response`. Afterwards, highlight `Invalid username or password`. This will help us to see directly this part of the response. Then I start the attack.

I see some differences in the length of the responses, but I can't find anything worth from these.

But, in the column that fetches the part of the response `Invalid username or password` a see a different one.

For the user `af` the response is `Invalid username or password` while on all the others there is `Invalid username or password.`

So, this means this username is a bit different and can be a potential candidate. Add this username in the initial response that we sent to the Intruder, and make the `testPassword` as our payload now. 

Add the candidate passwords and start the attack. The length of the responses, one is significantly lower as the others. So the length of `184` is for the `yankees` password, and the response says `HTTP/2 302 Found`.

We login with the credentials `af:yeankees` and the lab is solved.

-----

### Lab.3 - Username Enumeration via Response Timing

The challenge is to enumerate a valid username, brute-force the password and access the account page.

There is an additional account which can be accesses `wiener:peter`.

I try to login with some inexistent credentials, and see the body of the request:

`username=testUser&password=testPassword` -> I highlight the `testUser` and send it to Intruder, add the Sniper Attack and add the username candidates provided in the lab, and start the attack.

I see now that I not only have `Invalid username or password`, in most of the responses I received a `You have made too many incorrect login attempts. Please try again in 30 minute(s).` Meaning that this is a protection measure and blocked us to brute-force.

But, when I add the header `X-Forwarded-For: 1` I receive again the `Invalid username or password`. This happens because this header is used to identify the originating IP address of a client connecting to a web server through a proxy or load balancer. But, by setting the value to `1` it makes it invalid, and confuses the server.

What's also something to consider is that when I get this response the response time is approximately `84 milliseconds` 

Now, when I enter a valid username, such as `wiener` and a short password with just an `h` the response is `48 milliseconds`. If i make the password with two characters `ha` I got a time of `62 milliseconds`. But if I make it longer `halilberisha` the response time is `97 milliseconds`.

This behavior doesn't happen when the username is invalid. There the response time is approximately the same always.

Send this to the `Intruder` and select `Pitchfork attack`. Add the payload position to the `X-Forwarded-For`: `X-Forwarded-For: §3§`, and for the username parameter.

Select the Payload position: 1 and choose the type as `Numbers`, as we want to iterate through numbers on X-Forwaded-For in order to not block us. Put the range let's say from 1 to 100, with a step size of 1. 

And in the payload position: 2 select the list, and paste the list from the provided usernames in the lab.

Also, create a very long password, as we want to see the response times. Now, I started the attack.

After the attack has been finished, in the columns, add also the **Response received** and sort by it to see the time.

We see that the username `access` has a much bigger time, of 460, so that should be a candidate.

Now, modify the request, add the `access` as a username, and make the password now the payload. Paste the copied candidates from the lab and start the attack. Also, the payload for the ip spoofing should remain the same.

After the attack has finished, we have a `302 Found` and it is for the password `jordan`.

Now, we login to the page with `access:jordan` and the lab is solved.

## Flawed Brute-Force Protection

Brute-Force protection revolves around trying to make it as tricky as possible to automate the process and slow down the rate at which the attacker can attempt logins:
- Locking the account that the remote user is trying to access if too many failed login attempts.
- Blocking the remote user's IP address if they make too many login attempts in short time.

But, neither of those are invulnerable, especially if implemented with a flawed logic.

An example can be for example if your IP address is blocked. In some cases, the counter for the how many attempts you did to log in resets, if the IP owner logs in successfully.

In this case, the attacker would simply log in to their account every few attempts, and then can continue with brute-forcing. This can be done by just including your credentials in the wordlist.

### Lab.4 - Broken Brute-Force Protection, IP Block

The credentials to login are `wiener:peter`, and the goal is to find the victim `carlos` password, and login to their account page.

After two tries, I got blocked for 1 minute. This protection mechanisms, tries to block the brute-forcing. But, this counter is being reset when I login with correct credentials like `wiener:peter`.

In this case, I send the request to the Burp Intruder, and choose the `Pitchfork Attack`.

I add the payloads to both username and password. And in the username, I put only wiener, and carlos. But I repeat them a couple of times, around a hundred.

Then I take the list provided by the lab for potential passwords, and I modify it. Every second password I put my correct one `peter`. So, when I start the attack, the protection mechanism will not block me.

I start the attack, and I got a lot of `302 Found` because it's being logged into the `wiener:peter`, but among them there is one for carlos, and it's password is `123456789`.

So, i try to login with that, and the lab is solved.

![Pasted_image_20250121162013](https://github.com/user-attachments/assets/89f2cae3-fb40-40b6-ae7f-afdc8e3816e7)

---------

### Account Locking

Another protection mechanisms is to lock the account if a number of suspicious criteria is met, like a set number of failed login attempts.

But, as with the normal login errors, the responses provided from the server can also help an attacker to enumerate usernames.

### Lab.5 - Username Enumeration via Account Lock

The goal is to gain credentials of a user with the provided candidate usernames and passwords and access its page. The lab uses account locking, but has a logic flaw.

Let's send the login page with some non-existent credentials to the Intruder.

There, choose the `Cluster Bomb Attack` which means that a payload will be allocated to each position, and the intruder will iterate through all the possibilities.

Now, our initial body is `username=testUser&password=testPassword`. Add a payload position at the username, and an empty one at the end of the value of password. We need the second one, as we want to send a couple of times the password to the particular user.

In the Payloads for the position 1 I chose the simple list and added the candidate usernames, and in the second position I chose the null payloads and generated 5 payloads.

Now, start the attack, and observe the responses. I see that some response is longer than the others. This is the response for the account `athena`, and after I check the response, I see that it says **"You have made too many incorrect login attempts. Please try again in 1 minute(s)"**. 

But, in the others it just says **"Invalid username or password"**. This makes me think that the `athena` username exists, and now let's try the passwords from the candidate list.

I modified the payload like the following: `username=athena&password=§testPassword§` and choose the `Sniper Attack` and in the Simple list payload I added the candidate passwords.

To make the job easier I added a `GREP Extract` from the Settings for the message saying if we made `too many incorrect messags` or if there is an `invalid username or password`, and started the attack.

In the responses, I see one, that doesn't have a message at all. This is for the password `mustang.`

Now, after waiting for 1 minute, I tried the combination of the username and password `athena:mustang` I got access and solved the lab.

-------

# User Rate Limiting

Another protection mechanisms against Brute-Force Attacks is through user rate limiting, meaning that making too many login attempts in a short period of time, causes your IP address to be blocked.

Typically to unblock your ip address there are the following ways:
- Automatically after some time
- Manually by an administrator
- Manually by the user after completing the CAPTCHA

Some ways to bypass this behavior is to manipulate the IP address or sometimes to work out how to guess multiple passwords with a single request.

### Lab.6 - Broken Brute-Force Protection, Multiple Credentials per Request

We have the victim's username which is `carlos`, and to solve the lab we need to find the password from the candidate passwords provided by the lab.

I opened the login page on the lab and tried `carlos:testPassword` in order to check the request and the response in Burp.

Here I see something different, now the request sends the credentials as a JSON:

```json
{"username":"carlos","password":"testPassword"}
```

Let's try the Intruder and set a payload to the password, and try the Snipper Attack with our provided candidate passwords.

I got blocked saying `You have made too many incorrect login attempts. Please try again in 1 minute(s)`.

Since, it's JSON format, let's try to give more than one password in the request, in an array format.

```json
{"username":"carlos","password":["testPassword", "testPassword2]}
```

And we got the message saying: `Invalid username or password` so it means it accepts an array of passwords, where I will put all the candidate passwords that I have.

In the end the body would look like this:

```json
{"username":"carlos","password":["123456",
"password",
"12345678",
"qwerty",
"123456789",
"12345",
"1234",
"111111",
"1234567",
"dragon",
"123123",
"baseball",
"abc123",
"football",
"monkey",
...
```

And when I send this request, I got a `302 Found`. I select "Send this request to the browser" and the lab is solved.




