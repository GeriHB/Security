Usually servers don't store any information about the JWTs that they issue, and each token is a self-contained entity.

This introduces a fundamental problem - the server doesn't know anything about the original contents of the token, or even what the original signature was.

So, if the server doesn't verify the signature properly, there's nothing to stop an attacker from making changes to the token.

```json
{
    "username": "carlos",
    "isAdmin": false
}
```

If the server identifies the session bases on this username, modifying it will allow impersonating other logged-in users. Same with the `isAdmin` it can be used for privilege escalation.

## Accepting Arbitrary Signatures

JWT libraries provide methods for `verifying` and `decoding`.

For example `Node.js` library `jsonwebtoken` has `verify()` and `decode()` and developers sometimes confuse these two methods and only pass the decode, meaning no verification takes place at all.

### Lab.1 - JWT Authentication Bypass via Unverified Signature

The server doesn't verify the signature of any JWTs. 

To solve the lab, the session token should be modified to access the `/admin` then delete the user `carlos`. 

In the site you can use the credentials `wiener:peter`.

First, `JWT Editor` should be installed in `Burp Suite`. 

I visited the page and logged in with the `wiener` account, and the `JWT Editor` automatically highlights requests that contain JWT.

![Pasted_image_20250123100310](https://github.com/user-attachments/assets/d223eb85-e443-4188-bf93-0f6aeed48636)

When I click on the `POST /login` I see the Cookie in the response:

```http
Set-Cookie: session=eyJraWQiOiIzNWU3ZTZmYi1jMTBiLTRiYTAtOGQyNi1kYmE3OTZkZWUwZDkiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNzYyNjI1Niwic3ViIjoid2llbmVyIn0.OIZbY9YKZkApVRRXasl0qN8ewXx_chU-V2MVhEOzFH-qYfs6srBBxYx20iyGKDdhxf-xaIAwcRaqVKDsV8ejPRQSNZBFf9rjCsNzwL-6OuakUBsnsEUbagtDi-7bdu1bDnpH22DnYweEHxdWcR2lataoLU4t8ctiUo4LrEJjmjZJaf9tmKhLrKF0i-iAUkUUdQ2RUfVH_uJ4cdy6T1duDTG3c3xqlR2h0zE3ECwXrLjbRugM-sw_mV0PzxTEPD2bx-_DlUYmnkHwNg8opZgpI-_pSqKkPURkgJ7VVeGUe-n8j07NTaUDp-O2t78zFCmMO5-TBYLP2_vtsXMHYlOlLw;
```

Highlight the payload, and it will be automatically decoded in the `Burp Inspector.

So, this payload `eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNzYyNjI1Niwic3ViIjoid2llbmVyIn0` decoded is:

```json
{"iss":"portswigger","exp":1737626256,"sub":"wiener"}
```

Send the request with the JWT to the `Burp Repeater` and since the `JWT Editor` is installed, in the Request tab we have the `JSON Web Token` editor:

![Pasted_image_20250123100621](https://github.com/user-attachments/assets/b511ed59-0b8a-465c-b527-4234d72c686a)

Let's try without changing the JWT to access `/admin` and the response is `HTTP/2 401 Unauthorized`.

In the `JSON Web Token`, edit the payload and instead of `"sub": "wiener"` make it `"sub": "administrator"`.

Then, there is the modified `Serialized JWT`. 

![Pasted_image_20250123101017](https://github.com/user-attachments/assets/691c73e1-0c62-4b62-b27c-5579e681ea29)

Then, just send the request, and I have a `HTTP/2 200 OK` on the `/admin`. There I can see the link to delete `carlos`:

```html
                       <div>
                            <span>wiener - </span>
                            <a href="/admin/delete?username=wiener">Delete</a>
                        </div>
                        <div>
                            <span>carlos - </span>
                            <a href="/admin/delete?username=carlos">Delete</a>
                        </div>
```

Put the link in the request, and the `carlos` is deleted and the lab is solved.

-------

## Accepting Tokens with no Signature

JWT header contains an `alg` parameter, which tells the server which algorithm was used to sign the token, meaning which algorithm it needs to use to verify it.

This is dangerous as the server has no option but to trust the user-controllable input from the token, which at this point hasn't been verified at all.

So, the attacker can influence how the server checks whether the token is trustworthy.

JWTs can also be left unsigned `"alg": "none"`. Servers, usually reject tokens with no signature.

However, this kind of filtering relies on string parsing, sometimes it can be bypassed using obfuscation techniques, such as mixed capitalization and unexpected encodings.

### Lab.2 - JWT Authentication Bypass via Flawed Signature Verification

The server insecurely accepts unsigned JWTs. To solve the lab you should access `/admin` and delete `/carlos`.  A user that can be used to login is `wiener:peter`.

I login with `wiener`, and send the `POST` request to the Burp Repeater.

There I access `JSON Web Token` editor, and change the `sub` to `administrator`. 

Afterwards, I click the `Attack` and choose `"none" Signing Algorithm`. This modifies the JWT to:
`eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNzYyOTIwNCwic3ViIjoiYWRtaW5pc3RyYXRvciJ9.`

I send this request to `/admin` and I have access to the admin panel.

There, I see the link to delete `carlos`, which is `/admin/delete?username=carlos`, I send a `POST` request here, and the lab is solved.

![Pasted_image_20250123105300](https://github.com/user-attachments/assets/0aa14909-49f5-41ba-b937-f1131b5d2bba)

----------
