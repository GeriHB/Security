Backend servers can sometimes be made to ignore the `Content-Length` header, which means ignoring the body of the incoming requests, or simply saying treating the `Content-Length` as `0`.

This makes way for request smuggling without `chunked tranfer encoding` or `HTTP/2 downgrading`.

So if the backend has this behavior, but frontend uses `Content-Length` to determine where the requests ends, this discrepancy can be exploited for HTTP request smuggling.

This usually is present on endpoints that aren't expecting `POST` requests, so they assume that no requests have a body. Prime candidates for this are endpoints that trigger server-level redirects and requests for static files.

Even if no endpoints can be found, there may we ways to exploit this.

For example when a request's header trigger a server error, some servers issue an error response without consuming the request body off the socket. Now, if they don't close the connection afterwards, this can provide an alternative CL.0 desync possibility.

Another way may be to try `GET` requests with an obfuscated `Content-Length` header, and if you are able to hide this from the backend but not frontend, this causes also a desync.

## Exploit: CL.0 request smuggling

The backend ignores the `Content-Length` header on requests to some endpoints, and the goal to solve the lab is to identify a vulnerable endpoint, smuggle a request and access the admin panel at `/admin` and delete the user `carlos`.

To identify a candidate for this attack there are three candidates to be looked for:

- POST request to a static file.
- POST request to a server level redirect.
- POST request that triggers a server side error.

Then to perform this we need to `send attack and normal request over the same TCP connection`, which can be done by setting the header `Connection: Keep-Alive`, enable HTTP/1 Connection re-use and Send Group - Single Connection.

Grab a static file and send it to the Burp Repeater, and downgrade to HTTP/1.1.

Change it to `POST` request and send it to see if you get a `200 OK`.  

Send also a request to the endpoint to the Repeater, to use it as a normal request, downgrade the protocol again to HTTP/1.1.

Add the `Connection: Keep-Alive`, and under settings enable `HTTP/1 connection reuse`.

Then add both the attack and normal request to a tab group.

Afterwards send the group in sequence as single connection.

We see that we got a `200 OK` for the attack request but not for the normal one:

```http
HTTP/1.1 404 Not Found
Content-Type: text/html; charset=utf-8
Set-Cookie: session=RIPNfOHlvc9HGhUrK72SmfmbN9I9BDBL; Secure; HttpOnly; SameSite=None
X-Frame-Options: SAMEORIGIN
Keep-Alive: timeout=10
Content-Length: 24

<p>Not Found: /halil</p>
```

So, now put `/admin` instead of `/halil` in the attack request.

Now, in the normal request we have gained access to the admin panel:

```http
...
                    <section>
                        <h1>Users</h1>
                        <div>
                            <span>wiener - </span>
                            <a href="/admin/delete?username=wiener">Delete</a>
                        </div>
                        <div>
                            <span>carlos - </span>
                            <a href="/admin/delete?username=carlos">Delete</a>
                        </div>
                    </section>
...
```

Copy the link to delete the user `carlos` and put it instead of just `/admin`.

And we have a:

```http
HTTP/1.1 302 Found
Location: /admin
Set-Cookie: session=RAcE12wWYNxxyIyM54G6VfSdJ5pn07Jg; Secure; HttpOnly; SameSite=None
X-Frame-Options: SAMEORIGIN
Keep-Alive: timeout=10
Content-Length: 0
```

And now the lab is solved.

