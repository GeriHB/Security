Is a powerful request smuggling attack that makes it possible to steal responses intended for other users, thus compromising their accounts or even the entire site.

How does this happen?

When you smuggle a request, the scenario is that the frontend sees one request, but the backend produces more. 

So, when the request is sent, and the response received, the frontend presents this, but then another response comes, for which there was no request.

This is put into the queue! When the next request goes and produces another response, the first response in the queue will be presented.

So, when the response queue is poisoned the attacker can send an arbitrary request to capture another user's response.

Using tools like Burp Intruder, an attacker can automate the process of reissuing the request, and by doing so, they can grab an assortment of responses intended for different users.

The stealing of responses can be for as long as the frontend/backend connection remains open. A common default is to terminate a connection after it has handled 100 requests.

## Response queue poisoning H2.T

The goal is to delete the user `carlos` by using the response queue poisoning to break into the admin panel at /admin. Admin user will log in every 15 seconds.

After confirming that we got the vulnerability, we need to create a complete smuggled request, which means to send a request that frontend will see as one, but the backend will see as two complete requests. Without taking anything from the normal request.

This way we will poison the queue, and hopefully got the admin cookie.

In the attack request, I put the `Transfer-Encoding: chunked` and a `0` to separate two requests:

```http
POST /awcavcrsv HTTP/2
Host: 0a0a006e03773eb7812c433b008400fe.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

0

GET /wuchasdkuhce HTTP/1.1
Host: 0a0a006e03773eb7812c433b008400fe.web-security-academy.net


```

It's really important to put a `\r\n` at the end of the second request, as this will make it complete, and nothing will be appended.

Sending this, I got a `404 Not Found` which is pretty normal. This is because none of the directions that I'm searching in both requests exists.

This is intentional, since we want to filter the responses that we don't need.

Since, it is difficult to manually send the request exactly at the time when the admin logs in and to poison the queue at that time, I will automate the process using `Burp Intruder`.

So send this request to the Intruder, choose the `Null Payload` and configure the payload to `Continue indefinitely`.

Create e `resource pool` which sends a max. concurrent requests: `1` and with a delay of let's say a bit below 1 seconds `800 milliseconds`.

Really important is that at `Settings` to disable the `Update Content-Length header`.

Now, when we start the attack, we should look out and wait for the status code of `302` as that will be the redirect to the admin page. Meaning that at the time when the admin wanted to log in, the queue was poisoned, and the admin got a 404, but we got the 302.

And there is the Cookie as well:

![](../../../../images/Pasted image 20250116145602.png)

Now, using `Repeater` set this cookie and go to `/admin`. 

This logs us in to the admin page, as the admin.

There you could see the link to delete the user `carlos`, which is `/admin/delete?username=carlos`. Put that with the admin cookie, and you will have a `302 Found` so the user got deleted.

```http
HTTP/2 302 Found
Location: /admin
X-Frame-Options: SAMEORIGIN
Content-Length: 0
```
