## Serialization

Converts complex data structures, such as objects and their fields, into a "flatter" format that can be sent and received as a sequential stream of bytes.

It makes it simpler to:
- Write complex data to inter-process memory, a file, or a database.
- Send complex data, for example, over a network, between different components of an app, or in an API call.

So, when serializing an object, the state is also persisted, meaning the object's attributes and their assigned values are preserved.

## Serialization vs Deserialization

Deserialization is the process of restoring the byte stream to a fully functional replica of the original object.

Then, the website's logic can interact with this deserialized object, like any other object.

Since many programming languages offer native support for serialization, the process also depends on the language. 

Some languages serialize objects into binary formats, and other different string formats, but also call serialization differently:
- Marshalling (Ruby)
- Pickling (Python)

Also, since all attributes are stored in the serialized data stream, including any private fields, to prevent them from being serialized, it must be marked as `transient` in the class declaration.

## What is Insecure Deserialization

Is when user-controllable data is deserialized by a website, and potentially enables the attacker to manipulate serialized objects in order to pass harmful data into the app code.

It's also possible to replace a serialized object with an object of an entirely different class.

Objects of any class that is available to the website will be deserialized and instantiated, regardless of which class was expected, and for this reason this vulnerability is sometimes called "object injection".

Even if an object of an unexpected class can cause an exception, the damage may already be done.

This because many of these attacks are completed before deserialization is finished, meaning that the deserialization can initiate an attack, even if the website's own functionality doesn't directly interact with the malicious object.

It's impossible to implement sanitization for every eventuality, and these checks are flawed because they rely on checking the data after it has been deserialized, which may be too late.

Languages that use a binary serialization format, are assumed trustworthy, because devs might think that users can't read or manipulate the data effectively.

These attacks are also possible due to the number of dependencies that are in modern websites, and a typical site might implement many different libraries, and each has their dependencies.

If an attacker is able to chain together a long series of unexpected method invocations, passing data into a sink that is unrelated to the initial source, it's almost impossible to anticipate the flow of malicious data and plug every potential hole.

